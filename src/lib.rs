#![feature(proc_macro, wasm_custom_section, wasm_import_module)]
#![feature(use_extern_macros)]
extern crate sodiumoxide;
extern crate wasm_bindgen;
extern crate libc_stub; // see comments on this crate for what this is

use std::fmt::{self, Write};

use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern {
    #[wasm_bindgen(js_namespace = console)]
    fn log(a: &str);
}

macro_rules! console_log {
    ($($t:tt)*) => (log(&format!($($t)*)))
}

#[wasm_bindgen]
pub fn run() {
    sodiumoxide::init().unwrap();

    // Generate some random bytes
    //
    // NB the random byte generator is very low quality, it's implemented in
    // the `libc-shim` crate via `read` currently.
    let bytes = sodiumoxide::randombytes::randombytes(10);
    console_log!("10 randomly generated bytes are {:?}", bytes);

    // Generate a sha256 digest
    let mut h = sodiumoxide::crypto::hash::sha256::State::new();
    h.update(b"Hello, World!");
    let digest = h.finalize();
    console_log!("sha256(\"Hello, World!\") = {}", AsHex(digest.as_ref()));
}

struct AsHex<'a>(&'a [u8]);

impl<'a> fmt::Display for AsHex<'a> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        for &byte in self.0.iter() {
            f.write_char(btoc(byte >> 4))?;
            f.write_char(btoc(byte))?;
        }
        return Ok(());

        fn btoc(a: u8) -> char {
            let a = a & 0xf;
            match a {
                0...9 => (b'0' + a) as char,
                _ => (b'a' + a - 10) as char,
            }
        }
    }
}
